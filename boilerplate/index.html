<html>
<head>
	<title>frame differencing</title>
	<style>
		body{
			margin: 0;
      /*cursor:none;*/
		}
	</style>
</head>
<body>
<script id="fs" type="x-fragment/x-shader">
uniform sampler2D texture; 
uniform float time; // seconds
varying vec2 vUv;
uniform vec2 resolution;

void main() {
    gl_FragColor = texture2D(texture, vUv);
}
</script>
<script id="vs" type="x-shader/x-vertex">

    varying vec2 vUv;
    uniform float time;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>
<script id="diffFs">
uniform sampler2D texture;
uniform sampler2D texture2;
uniform sampler2D texture3;
varying vec2 vUv;

void main() {
  vec4 tex0 = texture2D(texture, vUv);
  vec4 tex1 = texture2D(texture2, vUv);
  vec4 tex2 = texture2D(texture3, vUv);

  vec4 fc = (tex2 - tex1);
  float avg = dot(tex2.rgb - tex1.rgb, vec3(1.0))/3.0;
  // fc = avg <= 0.01  ? fc : 1.0-fc;
  vec4 add = (fc + tex0);
  gl_FragColor = (fc);//mod(add,tex2.r);
  // gl_FragColor = smoothstep(tex2,tex0,mod(add,tex2.r));
}
</script>
<script id="blurFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
uniform vec2 resolution;
uniform float mouseX;
uniform float mouseY;

varying vec2 vUv;

void main() {
  float step_w = 1.0/resolution.x;
  float step_h = 1.0/resolution.y;
  vec2 tc = vUv;
  vec4 input0 = texture2D(texture,tc);
   
  vec2 x1 = vec2(step_w, 0.0);
  vec2 y1 = vec2(0.0, step_h);
    
  input0 += texture2D(texture, tc+x1); // right
  input0 += texture2D(texture, tc-x1); // left
  input0 += texture2D(texture, tc+y1); // top
  input0 += texture2D(texture, tc-y1); // bottom

  input0 *=0.2;

  gl_FragColor = input0;
}
</script>
<script id="sharpenFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
uniform vec2 resolution;
uniform float mouseX;
uniform float mouseY;

varying vec2 vUv;
float kernel[9];
vec2 offset[9];
void main() {
  float step_w = 1.0/resolution.x;
  float step_h = 1.0/resolution.y;
  vec2 tc = vUv;
  vec4 input0 = texture2D(texture,tc);
   
  kernel[0] = -1.0; kernel[1] = -1.0; kernel[2] = -1.0;
  kernel[3] = -1.0; kernel[4] = 8.0; kernel[5] = -1.0;
  kernel[6] = -1.0; kernel[7] = -1.0; kernel[8] = -1.0; 


  offset[0] = vec2(-step_w, -step_h);
  offset[1] = vec2(0.0, -step_h);
  offset[2] = vec2(step_w, -step_h);
  offset[3] = vec2(-step_w, 0.0);
  offset[4] = vec2(0.0, 0.0);
  offset[5] = vec2(step_w, 0.0);
  offset[6] = vec2(-step_w, step_h);
  offset[7] = vec2(0.0, step_h);
  offset[8] = vec2(step_w, step_h);
    
  input0 += texture2D(texture, tc + offset[0]) * kernel[0];
  input0 += texture2D(texture, tc + offset[1]) * kernel[1];
  input0 += texture2D(texture, tc + offset[2]) * kernel[2];
  input0 += texture2D(texture, tc + offset[3]) * kernel[3];
  input0 += texture2D(texture, tc + offset[4]) * kernel[4];
  input0 += texture2D(texture, tc + offset[5]) * kernel[5];
  input0 += texture2D(texture, tc + offset[6]) * kernel[6];
  input0 += texture2D(texture, tc + offset[7]) * kernel[7];
  input0 += texture2D(texture, tc + offset[8]) * kernel[8];


  // input0 *=0.2;
  float kernelWeight = kernel[0] + kernel[2] + kernel[3] + kernel[4] + kernel[5] + kernel[6] + kernel[7] + kernel[8]; 

  if (kernelWeight <= 0.0) {
     kernelWeight = 1.0;
   }
  gl_FragColor = vec4((input0/kernelWeight).rgb, 1.0);
}
</script>
<script id="colorFs">
uniform sampler2D texture;
varying vec2 vUv;

vec3 rainbow(float h) {
  h = mod(mod(h, 1.0) + 1.0, 1.0);
  float h6 = h * 6.0;
  float r = clamp(h6 - 4.0, 0.0, 1.0) +
    clamp(2.0 - h6, 0.0, 1.0);
  float g = h6 < 2.0
    ? clamp(h6, 0.0, 1.0)
    : clamp(4.0 - h6, 0.0, 1.0);
  float b = h6 < 4.0
    ? clamp(h6 - 2.0, 0.0, 1.0)
    : clamp(6.0 - h6, 0.0, 1.0);
  return vec3(r, g, b);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(( (q.z + (q.w - q.y) / (6.0 * d + e))) ), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}


void main(){

  vec4 tex0 = texture2D(texture, vUv);
  vec3 hsv = rgb2hsv(tex0.rgb);

  hsv.r += 0.01;
  hsv.r = mod(hsv.r, 1.0);
  hsv.g *= 1.001;
  // hsv.g = mod(hsv.g, 1.0);
  vec3 rgb = hsv2rgb(hsv); 

  gl_FragColor = vec4(fract(rgb),1.0);
}
</script>
<script type="x-shader/x-fragment" id="flowFs">
 
    uniform vec2 resolution;
    uniform float time;
    uniform sampler2D texture;
    varying vec2 vUv;
    uniform float mouseX;
    uniform float mouseY;

    void main( void ){
      vec2 p = gl_FragCoord.xy / resolution.xy;
      
      // vec2 uv = p*0.15 + 0.25;
      vec2 uv = vUv;
      // vec2 uv = vUv*0.05 + vec2(0.62, 0.57);
      
      vec2 e = 1.0/resolution.xy;
      
      
      // float am1 = 0.5 + 0.5*sin( time );
      float am1 = 0.5 + 0.5*0.927180409;
      // float am2 = 0.5 + 0.5*cos( time );
      float am2 = 10.0;
      
      for( int i=0; i<20; i++ ){
        float h  = dot( texture2D(texture, uv,               -100.0).xyz, vec3(0.333) );
        float h1 = dot( texture2D(texture, uv+vec2(e.x,mouseX), -100.0).xyz, vec3(0.333) );
        float h2 = dot( texture2D(texture, uv+vec2(mouseY,e.y), -100.0).xyz, vec3(0.333) );
            // gradient
        vec2 g = 0.001*vec2( (h1-h), (h2-h) )/e;
            // isoline    
        vec2 f = g.yx*vec2(-1.0,1.0);
        // vec2 f = g.yx*vec2(10.0*mouseX, 10.0*mouseY);
        
        g = mix( g, f, am1 );
        
        uv -= 0.0001*g*am2;
      }
      
      vec3 col = texture2D(texture, uv).xyz;
      
        // col *= 2.0;
        
      gl_FragColor = vec4(col, 1.0);
    }
</script>
<script src="three.min.js"></script>
<script src="Detector.js"></script>
<script src="BinaryLoader.js"></script>
<script src="OrbitControls.js"></script>
<script src="main.js"></script>
</body>
</html>